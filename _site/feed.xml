<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WoodGhost</title>
    <description>Technical discuss &amp; Poems &amp; Offshore Fantasy</description>
    <link>http://woodghost.github.io/myblog/</link>
    <atom:link href="http://woodghost.github.io/myblog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 17 Apr 2017 11:45:22 +0800</pubDate>
    <lastBuildDate>Mon, 17 Apr 2017 11:45:22 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title></title>
        <description>
</description>
        <pubDate>Mon, 17 Apr 2017 11:45:22 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2017/04/2016-10-01-js-04/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2017/04/2016-10-01-js-04/</guid>
        
        
      </item>
    
      <item>
        <title>fetch API与Promise</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;参考自 https://developer.mozilla.org/en/docs/Web/API/Fetch_API
转载自 https://hacks.mozilla.org/2015/03/this-api-is-so-fetching
http://bubkoo.com/2015/05/08/introduction-to-fetch/
https://davidwalsh.name/fetch&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JavaScript 通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说它很有用，但它不是最佳API。它在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近JavaScript流行的Promise以及基于生成器的异步编程模型不太搭。&lt;/p&gt;

&lt;p&gt;简单的fetching示例&lt;/p&gt;

&lt;p&gt;在Fetch API中，最常用的就是fetch()函数。它接收一个URL参数，返回一个promise来处理response。response参数带着一个Response对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch(&quot;/data.json&quot;).then(function(res) {
  // res instanceof Response == true.
  if (res.ok) {
    res.json().then(function(data) {
      console.log(data.entries);
    });
  } else {
    console.log(&quot;Looks like the response wasn&#39;t perfect, got status&quot;, res.status);
  }
}, function(e) {
  console.log(&quot;Fetch failed!&quot;, e);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是提交一个POST请求，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch(&quot;http://www.example.org/submit.php&quot;, {
  method: &quot;POST&quot;,
  headers: {
    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;
  },
  body: &quot;firstName=Nikhil&amp;amp;favColor=blue&amp;amp;password=easytoguess&quot;
}).then(function(res) {
  if (res.ok) {
    alert(&quot;Perfect! Your settings are saved.&quot;);
  } else if (res.status == 401) {
    alert(&quot;Oops! You are not authorized.&quot;);
  }
}, function(e) {
  alert(&quot;Error submitting form!&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fetch()函数的参数和传给Request()构造函数的参数保持完全一致，所以你可以直接传任意复杂的request请求给fetch()。&lt;/p&gt;

&lt;h3 id=&quot;headers&quot;&gt;Headers&lt;/h3&gt;

&lt;p&gt;Fetch引入了3个接口，它们分别是 Headers,Request 以及 Response 。他们直接对应了相应的HTTP概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证cookies不能被第三方获取。&lt;/p&gt;

&lt;p&gt;Headers接口是一个简单的多映射的名-值表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var content = &quot;Hello World&quot;;
var reqHeaders = new Headers();
reqHeaders.append(&quot;Content-Type&quot;, &quot;text/plain&quot;);
reqHeaders.append(&quot;Content-Length&quot;, content.length.toString());
reqHeaders.append(&quot;X-Custom-Header&quot;, &quot;ProcessThisImmediately&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也可以传一个多维数组或者json：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;reqHeaders = new Headers({
  &quot;Content-Type&quot;: &quot;text/plain&quot;,
  &quot;Content-Length&quot;: content.length.toString(),
  &quot;X-Custom-Header&quot;: &quot;ProcessThisImmediately&quot;,
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Headers的内容可以被检索：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(reqHeaders.has(&quot;Content-Type&quot;)); // true
console.log(reqHeaders.has(&quot;Set-Cookie&quot;)); // false
reqHeaders.set(&quot;Content-Type&quot;, &quot;text/html&quot;);
reqHeaders.append(&quot;X-Custom-Header&quot;, &quot;AnotherValue&quot;);

console.log(reqHeaders.get(&quot;Content-Length&quot;)); // 11
console.log(reqHeaders.getAll(&quot;X-Custom-Header&quot;)); // [&quot;ProcessThisImmediately&quot;, &quot;AnotherValue&quot;]

reqHeaders.delete(&quot;X-Custom-Header&quot;);
console.log(reqHeaders.getAll(&quot;X-Custom-Header&quot;)); // []
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一些操作不仅仅对ServiceWorkers有用，本身也提供了更方便的操作Headers的API（相对于XMLHttpRequest来说——译者注）。&lt;/p&gt;

&lt;p&gt;由于Headers可以在request请求中被发送或者在response请求中被接收，并且规定了哪些参数是可写的，Headers对象有一个特殊的guard属性。这个属性没有暴露给Web，但是它影响到哪些内容可以在Headers对象中被改变。&lt;/p&gt;

&lt;p&gt;可能的值如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“none”: 默认的&lt;/li&gt;
  &lt;li&gt;“request”: 从Request中获得的Headers只读。&lt;/li&gt;
  &lt;li&gt;“request-no-cors”：从不同域的Request中获得的Headers只读。&lt;/li&gt;
  &lt;li&gt;“response”: 从Response获得的Headers只读。&lt;/li&gt;
  &lt;li&gt;“immutable” 在ServiceWorkers中最常用的，所有的Headers都只读。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;哪一种 guard 作用于 Headers 导致什么行为，详细定义在了这个规范中。例如，你不可以添加或者修改一个guard属性是”request”的Request Headers的”Content-Length”属性。同样地，插入”Set-Cookie”属性到一个Response headers是不允许的，因此ServiceWorkers是不能给合成的Response的headers添加一些cookies。&lt;/p&gt;

&lt;p&gt;如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出 TypeError 异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var res = Response.error();
try {
  res.headers.set(&quot;Origin&quot;, &quot;http://mybank.com&quot;);
} catch(e) {
  console.log(&quot;Cannot pretend to be a bank!&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;request&quot;&gt;Request&lt;/h3&gt;

&lt;p&gt;Request接口定义了通过HTTP请求资源的request格式。参数需要URL、method和headers，同时Request也接受一个特定的body，mode，credentials以及cache hints.&lt;/p&gt;

&lt;p&gt;最简单的 Request 当然是一个URL，可以通过URL来GET一个资源。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var req = new Request(&quot;/index.html&quot;);
console.log(req.method); // &quot;GET&quot;
console.log(req.url); // &quot;http://example.com/index.html&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以将一个建好的Request对象传给构造函数，这样将复制出一个新的Request。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var copy = new Request(req);
console.log(copy.method); // &quot;GET&quot;
console.log(copy.url); // &quot;http://example.com/index.html&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种用法通常见于ServiceWorkers。&lt;/p&gt;

&lt;p&gt;URL以外的其他属性的初始值能够通过第二个参数传给Request构造函数。这个参数是一个json：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var uploadReq = new Request(&quot;/uploadImage&quot;, {
  method: &quot;POST&quot;,
  headers: {
    &quot;Content-Type&quot;: &quot;image/png&quot;,
  },
  body: &quot;image data&quot;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;mode属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为same-origin，no-cors（默认）以及cors。&lt;/p&gt;

&lt;p&gt;same-origin模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arbitraryUrl = document.getElementById(&quot;url-input&quot;).value;
fetch(arbitraryUrl, { mode: &quot;same-origin&quot; }).then(function(res) {
  console.log(&quot;Response succeeded?&quot;, res.ok);
}, function(e) {
  console.log(&quot;Please enter a same-origin URL!&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;no-cors模式允许来自CDN的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的method只能是”HEAD”,”GET”或者”POST”。此外，任何 ServiceWorkers 拦截了这些请求，它不能随意添加或者改写任何headers，除了这些。第三，JavaScript不能访问Response中的任何属性，这保证了 ServiceWorkers 不会导致任何跨域下的安全问题而隐私信息泄漏。&lt;/p&gt;

&lt;p&gt;cors模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守CORS协议。只有有限的一些headers被暴露给Response对象，但是body是可读的。例如，你可以获得一个Flickr的最感兴趣的照片的清单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var u = new URLSearchParams();
u.append(&#39;method&#39;, &#39;flickr.interestingness.getList&#39;);
u.append(&#39;api_key&#39;, &#39;&amp;lt;insert api key here&amp;gt;&#39;);
u.append(&#39;format&#39;, &#39;json&#39;);
u.append(&#39;nojsoncallback&#39;, &#39;1&#39;);

var apiCall = fetch(&#39;https://api.flickr.com/services/rest?&#39; + u);

apiCall.then(function(response) {
  return response.json().then(function(json) {
    // photo is a list of photos.
    return json.photos.photo;
  });
}).then(function(photos) {
  photos.forEach(function(photo) {
    console.log(photo.title);
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你无法从Headers中读取”Date”属性，因为Flickr在Access-Control-Expose-Headers中设置了不允许读取它。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;response.headers.get(&quot;Date&quot;); // null
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;credentials枚举属性决定了cookies是否能跨域得到。这个属性与XHR的withCredentials标志相同，但是只有三个值，分别是”omit”（默认）,”same-origin”以及”include”。&lt;/p&gt;

&lt;p&gt;Request对象也可以提供 caching hints 给用户代理。这个属性还在安全复审阶段。Firefox 提供了这个属性，但是它目前还不起作用。&lt;/p&gt;

&lt;p&gt;Request还有两个只读的属性与ServiceWorks拦截有关。其中一个是referrer，表示Request的来源，可能为空。另外一个是context，是一个非常大的枚举集合定义了获得的资源的种类，它可能是image比如请求来自于img标签，可能是worker如果是一个worker脚本，等等。如果使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch()&lt;/code&gt;函数，这个值是fetch。&lt;/p&gt;

&lt;h3 id=&quot;response&quot;&gt;Response&lt;/h3&gt;

&lt;p&gt;Response实例通常在fetch()的回调中获得。但是它们也可以用JS构造，不过通常这招只用于ServiceWorkers。&lt;/p&gt;

&lt;p&gt;Response中最常见的成员是status（一个整数默认值是200）和statusText（默认值是”OK”），对应HTTP请求的status和reason。还有一个”ok”属性，当status为2xx的时候它是true。&lt;/p&gt;

&lt;p&gt;headers 属性是Response的Headers对象，它是只读的(with guard “response”)，url属性是当前Response的来源URL。&lt;/p&gt;

&lt;p&gt;Response 也有一个type属性，它的值可能是”basic”,”cors”,”default”,”error”或者”opaque。&lt;/p&gt;

&lt;p&gt;“basic”: 正常的，同域的请求，包含所有的headers除开”Set-Cookie”和”Set-Cookie2”。
“cors”: Response从一个合法的跨域请求获得，一部分header和body可读。
“error”: 网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。
“opaque”: Response从”no-cors”请求了跨域资源。依靠Server端来做限制。
“error”类型会导致fetch()函数的Promise被reject并回调出一个TypeError。&lt;/p&gt;

&lt;p&gt;还有一些属性只在ServerWorker作用域下有效。以正确的方式 返回一个Response针对一个被ServiceWorkers拦截的Request，可以像下面这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addEventListener(&#39;fetch&#39;, function(event) {
  event.respondWith(new Response(&quot;Response body&quot;, {
    headers: { &quot;Content-Type&quot; : &quot;text/plain&quot; }
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如你所见，Response有个接收两个可选参数的构造器。第一个参数是返回的body，第二个参数是一个json，设置status、statusText以及headers。&lt;/p&gt;

&lt;p&gt;静态方法Response.error()简单返回一个错误的请求。类似的，&lt;code class=&quot;highlighter-rouge&quot;&gt;Response.redirect(url, status)&lt;/code&gt;返回一个跳转URL的请求。&lt;/p&gt;

&lt;h3 id=&quot;body&quot;&gt;处理body&lt;/h3&gt;

&lt;p&gt;无论Request还是Response都可能带着body。由于body可以是各种类型，比较复杂，所以前面我们故意先略过它，在这里单独拿出来讲解。&lt;/p&gt;

&lt;p&gt;body可以是以下任何一种类型的实例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ArrayBuffer&lt;/li&gt;
  &lt;li&gt;ArrayBufferView(Uint8Array and friends)&lt;/li&gt;
  &lt;li&gt;Blob/File&lt;/li&gt;
  &lt;li&gt;字符串&lt;/li&gt;
  &lt;li&gt;URLSearchParams&lt;/li&gt;
  &lt;li&gt;FormData——目前不被Gecko和Blink支持，Firefox预计在版本39和Fetch的其他部分一起推出。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，Request 和 Response都为他们的body提供了以下方法，这些方法都返回一个 Promise 对象。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;arrayBuffer()&lt;/li&gt;
  &lt;li&gt;blob()&lt;/li&gt;
  &lt;li&gt;json()&lt;/li&gt;
  &lt;li&gt;text()&lt;/li&gt;
  &lt;li&gt;formData()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在使用非文本的数据方面，Fetch API和XHR相比提供了极大的便利。&lt;/p&gt;

&lt;p&gt;可以通过传body参数来设置Request的body：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var form = new FormData(document.getElementById(&#39;login-form&#39;));
fetch(&quot;/login&quot;, {
  method: &quot;POST&quot;,
  body: form
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Response的第一个参数是body：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var res = new Response(new File([&quot;chunk&quot;, &quot;chunk&quot;], &quot;archive.zip&quot;,
                       { type: &quot;application/zip&quot; }));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Request 和 Response（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch(&lt;/code&gt;)方法）都能够自动识别自己的content type，Request还可以自动设置”Content-Type” header，如果开发者没有设置它的话。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;流和克隆&lt;/h3&gt;

&lt;p&gt;非常重要的一点要说明，那就是Request和Response的body只能被读取一次！它们有一个属性叫bodyUsed，读取一次之后设置为true，就不能再读取了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var res = new Response(&quot;one time use&quot;);
console.log(res.bodyUsed); // false
res.text().then(function(v) {
  console.log(res.bodyUsed); // true
});
console.log(res.bodyUsed); // true

res.text().catch(function(e) {
  console.log(&quot;Tried to read already consumed Response&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑。&lt;/p&gt;

&lt;p&gt;有时候，我们希望多次访问body，例如，你可能想用即将支持的Cache API去缓存Request和Response，以便于可以离线使用，Cache要求body能被再次读取。&lt;/p&gt;

&lt;p&gt;所以，我们该如何让body能经得起多次读取呢？API提供了一个clone()方法。调用这个方法可以得到一个克隆对象。不过要记得，clone()必须要在读取之前调用，也就是先clone()再读取。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addEventListener(&#39;fetch&#39;, function(evt) {
  var sheep = new Response(&quot;Dolly&quot;);
  console.log(sheep.bodyUsed); // false
  var clone = sheep.clone();
  console.log(clone.bodyUsed); // false

  clone.text();
  console.log(sheep.bodyUsed); // false
  console.log(clone.bodyUsed); // true

  evt.respondWith(cache.add(sheep.clone()).then(function(e) {
    return sheep;
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;xmlhttprequest&quot;&gt;XMLHttpRequest&lt;/h2&gt;

&lt;p&gt;XHR is a bit overcomplicated in my opinion, and don’t get me started on why “XML” is uppercase but “Http” is camel-cased.  Anyways, this is how you use XHR now:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Just getting XHR is a mess!
if (window.XMLHttpRequest) { // Mozilla, Safari, ...
  request = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    request = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  }
  catch (e) {
    try {
      request = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    }
    catch (e) {}
  }
}

// Open, send.
request.open(&#39;GET&#39;, &#39;https://davidwalsh.name/ajax-endpoint&#39;, true);
request.send(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Of course our JavaScript frameworks make XHR more pleasant to work with, but what you see above is a simple example of the XHR mess.&lt;/p&gt;

&lt;h2 id=&quot;basic-fetch-usage&quot;&gt;Basic fetch Usage&lt;/h2&gt;

&lt;p&gt;A fetch function is now provided in the global window scope, with the first argument being the URL:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// url (required), options (optional)
fetch(&#39;https://davidwalsh.name/some/url&#39;, {
	method: &#39;get&#39;
}).then(function(response) {

}).catch(function(err) {
	// Error :(
});
Much like the updated Battery API, the fetch API uses JavaScript Promises to handle results/callbacks:

// Simple response handling
fetch(&#39;https://davidwalsh.name/some/url&#39;).then(function(response) {

}).catch(function(err) {
	// Error :(
});

// Chaining for more &quot;advanced&quot; handling
fetch(&#39;https://davidwalsh.name/some/url&#39;).then(function(response) {
	return //...
}).then(function(returnedValue) {
	// ...
}).catch(function(err) {
	// Error :(
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If you aren’t used to then yet, get used to it – it will soon be everywhere.&lt;/p&gt;

&lt;h2 id=&quot;request-headers&quot;&gt;Request Headers&lt;/h2&gt;

&lt;p&gt;The ability to set request headers is important in request flexibility. You can work with request headers by executing new Headers():&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create an empty Headers instance
var headers = new Headers();

// Add a few headers
headers.append(&#39;Content-Type&#39;, &#39;text/plain&#39;);
headers.append(&#39;X-My-Custom-Header&#39;, &#39;CustomValue&#39;);

// Check, get, and set header values
headers.has(&#39;Content-Type&#39;); // true
headers.get(&#39;Content-Type&#39;); // &quot;text/plain&quot;
headers.set(&#39;Content-Type&#39;, &#39;application/json&#39;);

// Delete a header
headers.delete(&#39;X-My-Custom-Header&#39;);

// Add initial values
var headers = new Headers({
	&#39;Content-Type&#39;: &#39;text/plain&#39;,
	&#39;X-My-Custom-Header&#39;: &#39;CustomValue&#39;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can use the append, has, get, set, and delete methods to modify request headers. To use request headers, create a Request instance :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var request = new Request(&#39;https://davidwalsh.name/some-url&#39;, {
	headers: new Headers({
		&#39;Content-Type&#39;: &#39;text/plain&#39;
	})
});

fetch(request).then(function() { /* handle response */ });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Let’s have a look at what Response and Request do!&lt;/p&gt;

&lt;h2 id=&quot;request-1&quot;&gt;Request&lt;/h2&gt;
&lt;p&gt;A Request instance represents the request piece of a fetch call. By passing fetch a Request you can make advanced and customized requests:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;method - GET, POST, PUT, DELETE, HEAD
url - URL of the request
headers - associated Headers object
referrer - referrer of the request
mode - cors, no-cors, same-origin
credentials - should cookies go with the request? omit, same-origin
redirect - follow, error, manual
integrity - subresource integrity value
cache - cache mode (default, reload, no-cache)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A sample Request usage may look like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var request = new Request(&#39;https://davidwalsh.name/users.json&#39;, {
	method: &#39;POST&#39;,
	mode: &#39;cors&#39;,
	redirect: &#39;follow&#39;,
	headers: new Headers({
		&#39;Content-Type&#39;: &#39;text/plain&#39;
	})
});

// Now use it!
fetch(request).then(function() { /* handle response */ });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Only the first parameter, the URL, is required. Each property becomes read only once the Request instance has been created. Also important to note that Request has a clone method which is important when using fetch within the Service Worker API – a Request is a stream and thus must be cloned when passing to another fetch call.&lt;/p&gt;

&lt;p&gt;The fetch signature, however, acts like Request so you could also do:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch(&#39;https://davidwalsh.name/users.json&#39;, {
	method: &#39;POST&#39;,
	mode: &#39;cors&#39;,
	redirect: &#39;follow&#39;,
	headers: new Headers({
		&#39;Content-Type&#39;: &#39;text/plain&#39;
	})
}).then(function() { /* handle response */ });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You’ll likely only use Request instances within Service Workers since the Request and fetch signatures can be the same. ServiceWorker post coming soon!&lt;/p&gt;

&lt;h2 id=&quot;response-1&quot;&gt;Response&lt;/h2&gt;

&lt;p&gt;The fetch’s then method is provided a Response instance but you can also manually create Response objects yourself – another situation you may encounter when using service workers. With a Response you can configure:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;type - basic, cors
url
useFinalURL - Boolean for if url is the final URL
status - status code (ex: 200, 404, etc.)
ok - Boolean for successful response (status in the range 200-299)
statusText - status code (ex: OK)
headers - Headers object associated with the response.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create your own response for service worker testing
// new Response(BODY, OPTIONS)
var response = new Response(&#39;.....&#39;, {
	ok: false,
	status: 404,
	url: &#39;/&#39;
});

// The fetch&#39;s `then` gets a Response instance back
fetch(&#39;https://davidwalsh.name/&#39;)
	.then(function(responseObj) {
		console.log(&#39;status: &#39;, responseObj.status);
	});
	```


The Response also provides the following methods:

- clone() - Creates a clone of a Response object.
- error() - Returns a new Response object associated with a network error.
- redirect() - Creates a new response with a different URL.
- arrayBuffer() - Returns a promise that resolves with an ArrayBuffer.
- blob() - Returns a promise that resolves with a Blob.
- formData() - Returns a promise that resolves with a FormData object.
- json() - Returns a promise that resolves with a JSON object.
- text() - Returns a promise that resolves with a USVString (text).

## Handling JSON

Let&#39;s say you make a request for JSON -- the resulting callback data has a json method for converting the raw data to a JavaScript object:

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;fetch(‘https://davidwalsh.name/demo/arsenal.json’).then(function(response) {
	// Convert to JSON
	return response.json();
}).then(function(j) {
	// Yay, &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt; is a JavaScript object
	console.log(j);
});
```&lt;/p&gt;

&lt;p&gt;Of course that’s a simple JSON.parse(jsonString), but the json method is a handy shortcut.&lt;/p&gt;

&lt;h2 id=&quot;handling-basic-texthtml-responses&quot;&gt;Handling Basic Text/HTML Responses&lt;/h2&gt;

&lt;p&gt;JSON isn’t always the desired request response format so here’s how you can work with an HTML or text response:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch(&#39;/next/page&#39;)
  .then(function(response) {
    return response.text();
  }).then(function(text) {
  	// &amp;lt;!DOCTYPE ....
  	console.log(text);
  });
  ```

You can get the response text via chaining the Promise&#39;s then method along with the text() method.

## Handling Blob Responses

If you want to load an image via fetch, for example, that will be a bit different:

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;fetch(‘https://davidwalsh.name/flowers.jpg’)
	.then(function(response) {
	  return response.blob();
	})
	.then(function(imageBlob) {
	  document.querySelector(‘img’).src = URL.createObjectURL(imageBlob);
	});
	```&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;blob()&lt;/code&gt;` method of the Body mixin takes a Response stream and reads it to completion.&lt;/p&gt;

&lt;h2 id=&quot;posting-form-data&quot;&gt;Posting Form Data&lt;/h2&gt;

&lt;p&gt;Another common use case for AJAX is sending form data – here’s how you would use fetch to post form data:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch(&#39;https://davidwalsh.name/submit&#39;, {
	method: &#39;post&#39;,
	body: new FormData(document.getElementById(&#39;comment-form&#39;))
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And if you want to POST JSON to the server:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch(&#39;https://davidwalsh.name/submit-json&#39;, {
	method: &#39;post&#39;,
	body: JSON.stringify({
		email: document.getElementById(&#39;email&#39;).value
		answer: document.getElementById(&#39;answer&#39;).value
	})
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Very easy, very eye-pleasing as well!&lt;/p&gt;

</description>
        <pubDate>Thu, 13 Apr 2017 15:43:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2017/04/js-fetchapi/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2017/04/js-fetchapi/</guid>
        
        <category>javascript,</category>
        
        <category>fetch</category>
        
        <category>API</category>
        
        
      </item>
    
      <item>
        <title>JS跨域问题的总结归纳</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;如何解决跨域问题&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;JSONP：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原理是：动态插入&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt;标签，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt;标签引入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;js&lt;/code&gt;文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;数据作为参数传入。&lt;/p&gt;

&lt;p&gt;由于同源策略的限制，&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlHttpRequest&lt;/code&gt;只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt;标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。&lt;/p&gt;

&lt;p&gt;优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JSONP&lt;/code&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;json+padding&lt;/code&gt;（内填充），顾名思义，就是把JSON填充到一个盒子里&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createJs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oScript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;script&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;oScript&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;text/javascript&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;oScript&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementsByTagName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;head&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;oScript&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;createJs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;jsonp.js&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
       &lt;span class=&quot;s1&quot;&gt;&#39;name&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;test&#39;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;CORS cross-origin resource share&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;服务器端对于&lt;code class=&quot;highlighter-rouge&quot;&gt;CORS&lt;/code&gt;的支持，主要就是通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;Access-Control-Allow-Origin&lt;/code&gt;来进行的。如果浏览器检测到相应的设置，就可以允许&lt;code class=&quot;highlighter-rouge&quot;&gt;Ajax&lt;/code&gt;进行跨域的访问。&lt;/p&gt;

&lt;p&gt;了解更多可以看 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS wiki&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过修改document.domain来跨子域&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将子域和主域的&lt;code class=&quot;highlighter-rouge&quot;&gt;document.domain&lt;/code&gt;设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用&lt;code class=&quot;highlighter-rouge&quot;&gt;document.domain&lt;/code&gt;进行跨域&lt;/p&gt;

&lt;p&gt;主域相同的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;document.domain&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用window.name来进行跨域&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;对象有个&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个&lt;code class=&quot;highlighter-rouge&quot;&gt;window.name&lt;/code&gt;的，每个页面对&lt;code class=&quot;highlighter-rouge&quot;&gt;window.name&lt;/code&gt;都有读写的权限，&lt;code class=&quot;highlighter-rouge&quot;&gt;window.name&lt;/code&gt;是持久存在一个窗口载入过的所有页面中的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用HTML5中新引进的&lt;code class=&quot;highlighter-rouge&quot;&gt;window.postMessage&lt;/code&gt;方法来跨域传送数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还有flash、在服务器上设置代理页面等跨域方式。个人认为&lt;code class=&quot;highlighter-rouge&quot;&gt;window.name&lt;/code&gt;的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法&lt;/p&gt;

</description>
        <pubDate>Sat, 01 Apr 2017 15:43:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2017/04/js-cross-origin/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2017/04/js-cross-origin/</guid>
        
        <category>javascript</category>
        
        
      </item>
    
      <item>
        <title>JS模块化标准的总结归纳</title>
        <description>&lt;h4 id=&quot;requirejs-implements-the-amd-api-commonjs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RequireJS&lt;/code&gt; implements the AMD API &lt;code class=&quot;highlighter-rouge&quot;&gt;CommonJS&lt;/code&gt;是一种规范 &lt;/h4&gt;

&lt;p&gt;以下是玉伯对这几种不同的模块化规范的解释&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者：玉伯
链接：https://www.zhihu.com/question/20351507/answer/14859415
来源：知乎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;amd--requirejs-&quot;&gt;AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。&lt;/h3&gt;

&lt;h3 id=&quot;cmd--seajs-&quot;&gt;CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。&lt;/h3&gt;

&lt;p&gt;类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。
还有不少⋯⋯&lt;/p&gt;

&lt;p&gt;这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。
目前这些规范的实现都能达成浏览器端模块化开发的目的。&lt;/p&gt;

&lt;p&gt;区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// CMD
define(function(require, exports, module) {
var a = require(&#39;./a&#39;)
a.doSomething()
// 此处略去 100 行
var b = require(&#39;./b&#39;) // 依赖可以就近书写
b.doSomething()
// ...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// AMD 默认推荐的是
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好
a.doSomething()
// 此处略去 100 行
b.doSomething()
...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还有一些细节差异，具体看这个规范的定义就好，就不多说了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;export-vs-module-export&quot;&gt;export vs module export&lt;/h3&gt;
&lt;p&gt;Module.exports才是真正的接口，exports只不过是它的一个辅助工具。　最终返回给调用的是Module.exports而不是exports。
所有的exports收集到的属性和方法，都赋值给了Module.exports。当然，这有个前提，就是Module.exports本身不具备任何属性和方法。如果，Module.exports已经具备一些属性和方法，那么exports收集来的信息将被忽略。&lt;/p&gt;

&lt;p&gt;CMD代码规范这里useful info，因为这就是人家seats的官方说明文件啦&lt;/p&gt;

&lt;p&gt;https://github.com/seajs/seajs/issues/242
除了给 exports 对象增加成员，还可以使用 return 直接向外提供接口。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define(function(require) {

// 通过 return 直接提供接口
return {
foo: &#39;bar&#39;,
doSomething: function() {}
};

});
exports Object
exports 是一个对象，用来向外提供模块接口。
define(function(require, exports) {

// 对外提供 foo 属性
exports.foo = &#39;bar&#39;;

// 对外提供 doSomething 方法
exports.doSomething = function() {};

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;另：一个做前端的女孩子的博客哦，http://www.cnblogs.com/skylar/p/4065455.html讲的也是蛮中肯的。
一个感觉很同好的程序员讲module.export 和 export的区别
http://weizhifeng.net/node-js-exports-vs-module-exports.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你肯定对Node.js模块中用来创建函数的exports对象很熟悉（假设一个名为rocker.js的文件）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.name = function() {
    console.log(&#39;My name is Lemmy Kilmister&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后你在另一个文件中调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var rocker = require(&#39;./rocker.js&#39;);
rocker.name(); // &#39;My name is Lemmy Kilmister&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是module.exports到底是个什么玩意儿? 它合法吗？
令人吃惊的是-module.exports是真实存在的东西。exports只是module.exports的辅助方法。你的模块最终返回module.exports给调用者，而不是exports。exports所做的事情是收集属性，如果module.exports当前没有任何属性的话，exports会把这些属性赋予module.exports。如果module.exports已经存在一些属性的话，那么exports中所用的东西都会被忽略。
把下面的内容放到rocker.js:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = &#39;ROCK IT!&#39;;
exports.name = function() {
    console.log(&#39;My name is Lemmy Kilmister&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后把下面的内容放到另一个文件中，执行它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var rocker = require(&#39;./rocker.js&#39;);
rocker.name(); // TypeError: Object ROCK IT! has no method &#39;name&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;rocker模块完全忽略了exports.name，然后返回了一个字符串’ROCK IT!’。通过上面的例子，你可能认识到你的模块不一定非得是模块实例（module instances）。你的模块可以是任何合法的JavaScript对象 - boolean，number，date，JSON， string，function，array和其他。你的模块可以是任何你赋予module.exports的值。如果你没有明确的给module.exports设置任何值，那么exports中的属性会被赋给module.exports中，然后并返回它。&lt;/p&gt;

&lt;p&gt;在下面的情况下，你的模块是一个类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = function(name, age) {
    this.name = name;
    this.age = age;
    this.about = function() {
        console.log(this.name +&#39; is &#39;+ this.age +&#39; years old&#39;);
    };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后你应该这样使用它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Rocker = require(&#39;./rocker.js&#39;);
var r = new Rocker(&#39;Ozzy&#39;, 62);
r.about(); // Ozzy is 62 years old
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在下面的情况下，你的模块是一个数组：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = [&#39;Lemmy Kilmister&#39;, &#39;Ozzy Osbourne&#39;, &#39;Ronnie James Dio&#39;, &#39;Steven Tyler&#39;, &#39;Mick Jagger&#39;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后你应该这样使用它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var rocker = require(&#39;./rocker.js&#39;);
console.log(&#39;Rockin in heaven: &#39; + rocker[2]); //Rockin in heaven: Ronnie James Dio
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在你应该找到要点了 - 如果你想要你的模块成为一个特别的对象类型，那么使用module.exports；如果你希望你的模块成为一个传统的模块实例（module instance），使用exports。
把属性赋予&lt;code class=&quot;highlighter-rouge&quot;&gt;module.exports&lt;/code&gt;的结果与把属性赋予给exports是一样的。看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports.name = function() {
    console.log(&#39;My name is Lemmy Kilmister&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面这个做的是一样的事情：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.name = function() {
    console.log(&#39;My name is Lemmy Kilmister&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是请注意，它们并不是一样的东西。就像我之前说的module.exports是真实存在的东西，exports只是它的辅助方法。话虽如此，exports还是推荐的对象，除非你想把你模块 的对象类型从传统的模块实例（module instance）修改为其他的。&lt;/p&gt;

&lt;p&gt;“exports 和 module.exports 引用同一个对象”&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;以下内容大部分来源于Stack Overflow和Wikipedia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;CommonJS is a way of defining modules with the help of an exports object, that defines the module contents. Simply put, a CommonJS implementation might work like this:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// someModule.js
exports.doSomething = function() { return &quot;foo&quot;; };

//otherModule.js
var someModule = require(&#39;someModule&#39;); // in the vein of node
exports.doSomethingElse = function() { return someModule.doSomething() + &quot;bar&quot;; };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Basically, CommonJS specifies that you need to have a require() function to fetch dependencies, an exports variable to export module contents and a module identifier (which describes the location of the module in question in relation to this module) that is used to require the dependencies. CommonJS has various implementations, including Node.js, which you mentioned.&lt;/p&gt;

&lt;p&gt;CommonJS was not particularly designed with browsers in mind, so it doesn’t fit in the browser environment very well (I really have no source for this–it just says so everywhere, including the RequireJS site.). Apparently, this has something to do with asynchronous loading, etc.&lt;/p&gt;

&lt;p&gt;On the other hand, RequireJS implements AMD, which is designed to suit the browser environment. Apparently, AMD started as an spinoff of the CommonJS Transport format and evolved into its own module definition API. Hence the similarities between the two. The new feature in AMD is the define() -function that allows the module to declare its dependencies before being loaded. For example, the definition could be:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define(&#39;module/id/string&#39;, [&#39;module&#39;, &#39;dependency&#39;, &#39;array&#39;],
function(module, factory function) {
  return ModuleContents;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So, CommonJS and AMD are JavaScript module definition APIs that have different implementations, but both come from the same origins.
AMD is more suited for the browser, because it supports asynchronous loading of module dependencies.&lt;/p&gt;

&lt;h3 id=&quot;requirejs-is-an-implementation-of-amd-while-at-the-same-time-trying-to-keep-the-spirit-of-commonjs-mainly-in-the-module-identifiers&quot;&gt;RequireJS is an implementation of AMD, while at the same time trying to keep the spirit of CommonJS (mainly in the module identifiers).&lt;/h3&gt;

&lt;p&gt;To confuse you even more, RequireJS, while being an AMD implementation, offers a CommonJS wrapper so CommonJS modules can almost directly be imported into use with RequireJS.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define(function(require, exports, module) {
  var someModule = require(&#39;someModule&#39;); // in the vein of node
  exports.doSomethingElse = function() { return someModule.doSomething() + &quot;bar&quot;; };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;AMD CMD commonjs requirejs……pageObject……
webpack
Question from stack overflow
Asynchronous module definition (AMD) and CommonJS are styles/specifications of writing modular code in javascript, while RequireJS and Browserify are 2 popular implementation/helper for them respectively.
That means AMD-requirejs Commonjs-Browserify&lt;/p&gt;

&lt;h3 id=&quot;requirejs-implements-the-amdasynchronous-module-definitions--api&quot;&gt;RequireJS implements the &lt;strong&gt;AMD(asynchronous module definitions )&lt;/strong&gt; API&lt;/h3&gt;
&lt;p&gt;http://requirejs.org/docs/whyamd.html
AMD&lt;/p&gt;

&lt;p&gt;Asynchronous module definition (AMD)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define(function {
  console.log(&#39;Awesome&#39;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CommonJS&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = function(){
  console.log(&#39;Awesome&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In our MVC structure, the actual example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Outfit view in dejafm
var Slider = require(&#39;util/Slider&#39;); var Tooltip = require(&#39;widget/Tooltip&#39;); var BasicView = require(&#39;app/view/View&#39;); var StyleTemplateView = require(&#39;app/view/StyleTemplateView&#39;); var BasicModel = require(&#39;app/model/Model&#39;); var StyleModel = require(&#39;app/model/StyleModel&#39;);

module.exports = new OutfitsView();

var Audios = {} module.exports = Audios;


//modules in deja3 index webpage
Util.js
exports.os = os; 
NavBar.js
exports.show = function show(){  el.removeAttr(&#39;hidden&#39;).removeClass(&#39;fadeOutUp&#39;).addClass(&#39;fadeInDown&#39;); } exports.hide = function hide(){  el.removeClass(&#39;fadeInDown&#39;).addClass(&#39;fadeOutUp&#39;); }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 31 Mar 2017 15:43:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2017/03/js-modules/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2017/03/js-modules/</guid>
        
        <category>javascript,</category>
        
        <category>module</category>
        
        
      </item>
    
      <item>
        <title>三月的最后一天</title>
        <description>&lt;p&gt;白驹过隙，四月将至，收拾行囊，重新开始
借此机会将以往笔记整理成blogs按时间顺序陆续贴出，包括新近看到的学习笔记&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Mar 2017 15:32:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2017/03/last-day-march/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2017/03/last-day-march/</guid>
        
        <category>life,</category>
        
        <category>mood</category>
        
        
      </item>
    
      <item>
        <title>JS深拷贝浅拷贝问题</title>
        <description>&lt;p&gt;浅拷贝只是复制引用(Reference)，
拷贝后，&lt;code class=&quot;highlighter-rouge&quot;&gt;a.obj === b.obj&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;深拷贝是创建(clone)了一个“一模一样”的对象，并保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;a.obj中，所以 a.obj !== b.obj&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ps:对于引用类型，===运算符当左值和右值是同一个对象，也就是内存地址相同时返回true。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ES6之后，有很方便的浅copy方法
&lt;code class=&quot;highlighter-rouge&quot;&gt;
var obj = { a: 1 };
var copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实现es5版本的Object.assign：
&amp;gt; 来自 https://cnodejs.org/topic/56c49662db16d3343df34b13&lt;/p&gt;

&lt;p&gt;实现步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;判断是否原生支持该函数，如果不存在的话创建一个立即执行函数，该函数将创建一个assign函数绑定到Object上。&lt;/li&gt;
  &lt;li&gt;判断参数是否正确(目的对象不能为空，我们可以直接设置{}传递进去,但必须设置该值)
使用Object在原有的对象基础上返回该对象，并保存为out&lt;/li&gt;
  &lt;li&gt;使用for…in循环遍历出所有的可枚举的自有对象。并复制给新的目标对象(hasOwnProperty返回非原型链上的属性)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (typeof Object.assign != &#39;function&#39;) {
  (function () {
	Object.assign = function (target) {
	 &#39;use strict&#39;;
	 if (target === undefined || target === null) {
	   throw new TypeError(&#39;Cannot convert undefined or null to object&#39;);
	 }

	 var output = Object(target);
	 for (var index = 1; index &amp;lt; arguments.length; index++) {
	   var source = arguments[index];
	   if (source !== undefined &amp;amp;&amp;amp; source !== null) {
	     for (var nextKey in source) {
	       if (source.hasOwnProperty(nextKey)) {
	         output[nextKey] = source[nextKey];
	       }
	     }
	   }
	 }
	 return output;
	};
})();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;深拷贝&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b = JSON.parse( JSON.stringify(a) )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;局限性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;无法复制函数&lt;/li&gt;
  &lt;li&gt;原型链没了，对象就是object，所属的类没了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;知乎上一位作者对js拷贝问题的解答以及他的另一篇文章
https://www.zhihu.com/question/23031215&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002801042&quot;&gt;深入剖析js深拷贝&lt;/a&gt;!&lt;/p&gt;

</description>
        <pubDate>Fri, 31 Mar 2017 14:43:36 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2017/03/js-copy/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2017/03/js-copy/</guid>
        
        <category>javascript</category>
        
        
      </item>
    
      <item>
        <title>项目中MVC的学习与总结</title>
        <description>&lt;p&gt;在Github上面有个 repository 专门详细的记载了学习和实践整个项目的过程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/woodghost/notes/tree/master/dejafm&quot;&gt;notes 项目链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 09 Aug 2016 18:06:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2016/08/mvc-summary/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2016/08/mvc-summary/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JS高级程序设计与实践</title>
        <description>
</description>
        <pubDate>Tue, 09 Aug 2016 18:06:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2016/08/js-03/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2016/08/js-03/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>HTTP协议相关笔记</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;非常常见的状态码&lt;/h3&gt;

&lt;p&gt;首先是罗列一些学习工作中出现几率很高的状态码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;200 OK&lt;/li&gt;
  &lt;li&gt;304 Not Modified 未修改&lt;/li&gt;
  &lt;li&gt;400 Bad Request 错误的请求&lt;/li&gt;
  &lt;li&gt;401 Unauthorized 未授权&lt;/li&gt;
  &lt;li&gt;403 Forbidden 拒绝访问&lt;/li&gt;
  &lt;li&gt;404 Not Found 未找到&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;500 Internal Server Error 内部服务器错误&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;501 Not Implemented 未执行&lt;/li&gt;
  &lt;li&gt;502 Bad Gateway 错误的网关&lt;/li&gt;
  &lt;li&gt;503 Service Unavailable 服务不可用&lt;/li&gt;
  &lt;li&gt;504 Gateway Timeout 网关超时&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;更多内容&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;标准扩展码&lt;/h4&gt;

&lt;p&gt;1xx Informational 信息化&lt;/p&gt;

&lt;p&gt;100 Continue 继续&lt;/p&gt;

&lt;p&gt;101 Switching Protocols 交换协议&lt;/p&gt;

&lt;p&gt;102 Processing 处理&lt;/p&gt;

&lt;p&gt;2xx Success 成功&lt;/p&gt;

&lt;p&gt;200 OK&lt;/p&gt;

&lt;p&gt;201 Created 创建&lt;/p&gt;

&lt;p&gt;202 Accepted 已接受&lt;/p&gt;

&lt;p&gt;203 Non-Authoritative Information 非授权信息&lt;/p&gt;

&lt;p&gt;204 No Content 无内容&lt;/p&gt;

&lt;p&gt;205 Reset Content 重置内容&lt;/p&gt;

&lt;p&gt;206 Partial Content 部分内容&lt;/p&gt;

&lt;p&gt;207 Multi-Status 多状态&lt;/p&gt;

&lt;p&gt;208 Already Reported 已报告&lt;/p&gt;

&lt;p&gt;226 IMIM Used 使用的&lt;/p&gt;

&lt;p&gt;3xx Redirection 重定向&lt;/p&gt;

&lt;p&gt;300 Multiple Choices 多种选择&lt;/p&gt;

&lt;p&gt;301 Moved Permanently 永久移动&lt;/p&gt;

&lt;p&gt;302 Found 发现&lt;/p&gt;

&lt;p&gt;303 See Other 查看其它&lt;/p&gt;

&lt;p&gt;304 Not Modified 未修改&lt;/p&gt;

&lt;p&gt;305 Use Proxy 使用代理&lt;/p&gt;

&lt;p&gt;306 Switch Proxy 开关代理&lt;/p&gt;

&lt;p&gt;307 Temporary Redirect 临时重定向&lt;/p&gt;

&lt;p&gt;308 Permanent Redirect 永久重定向&lt;/p&gt;

&lt;p&gt;4xx Client Error 客户端错误&lt;/p&gt;

&lt;p&gt;400 Bad Request 错误的请求&lt;/p&gt;

&lt;p&gt;401 Unauthorized 未授权&lt;/p&gt;

&lt;p&gt;402 Payment Required 需要付费&lt;/p&gt;

&lt;p&gt;403Forbidden 拒绝访问&lt;/p&gt;

&lt;p&gt;404 Not Found 未找到&lt;/p&gt;

&lt;p&gt;405 Method Not Allowed 不允许的方法&lt;/p&gt;

&lt;p&gt;406 Not Acceptable 不可接受&lt;/p&gt;

&lt;p&gt;407 Proxy Authentication Required 代理服务器需要身份验证&lt;/p&gt;

&lt;p&gt;408 Request Timeout 请求超时&lt;/p&gt;

&lt;p&gt;409 Conflict 冲突&lt;/p&gt;

&lt;p&gt;410 Gone 完成&lt;/p&gt;

&lt;p&gt;411 Length Required 需要长度&lt;/p&gt;

&lt;p&gt;412 Precondition Failed 前提条件失败&lt;/p&gt;

&lt;p&gt;413 Payload Too Large 负载过大&lt;/p&gt;

&lt;p&gt;414 URI Too Long 太长&lt;/p&gt;

&lt;p&gt;415 Unsupported Media Type 不支持的媒体类型&lt;/p&gt;

&lt;p&gt;416 Range Not Satisfiable 的范围不合适&lt;/p&gt;

&lt;p&gt;417 Expectation Failed 预期失败&lt;/p&gt;

&lt;p&gt;418 I’m a teapot 我是一个茶壶&lt;/p&gt;

&lt;p&gt;421 Misdirected Request 误导请求&lt;/p&gt;

&lt;p&gt;422 Unprocessable Entity 无法处理的实体&lt;/p&gt;

&lt;p&gt;423 Locked 锁定&lt;/p&gt;

&lt;p&gt;424 Failed Dependency 失败的依赖&lt;/p&gt;

&lt;p&gt;426 Upgrade Required 升级所需&lt;/p&gt;

&lt;p&gt;428 Precondition Required 所需的先决条件&lt;/p&gt;

&lt;p&gt;429 Too Many Requests 太多的请求&lt;/p&gt;

&lt;p&gt;431 Request Header Fields Too Large 请求头字段太大&lt;/p&gt;

&lt;p&gt;451 Unavailable For Legal Reasons 不可出于法律原因&lt;/p&gt;

&lt;p&gt;5xx Server Error 服务器错误&lt;/p&gt;

&lt;p&gt;500 Internal Server Error 内部服务器错误&lt;/p&gt;

&lt;p&gt;501 Not Implemented 未执行&lt;/p&gt;

&lt;p&gt;502 Bad Gateway 错误的网关&lt;/p&gt;

&lt;p&gt;503 Service Unavailable 服务不可用&lt;/p&gt;

&lt;p&gt;504 Gateway Timeout 网关超时&lt;/p&gt;

&lt;p&gt;505 HTTP Version Not Supported 不支持HTTP版本&lt;/p&gt;

&lt;p&gt;506 Variant Also Negotiates 变体也进行协商&lt;/p&gt;

&lt;p&gt;507 Insufficient Storage 存储空间不足&lt;/p&gt;

&lt;p&gt;508 Loop Detected 检测到循环&lt;/p&gt;

&lt;p&gt;510 Not Extended 不延长&lt;/p&gt;

&lt;p&gt;511 Network Authentication Required 网络需要身份验证&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 18:06:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2016/08/http-protocol/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2016/08/http-protocol/</guid>
        
        <category>http</category>
        
        
      </item>
    
      <item>
        <title>第一篇Leetcode学习笔记</title>
        <description>&lt;p&gt;First of all, 看了最最基本的leetcode 371 和 001
都是两个数求和这种，诚然，可以直接return a + b, 但是大部分公司显然不会满足这种答案。所以借此机会认真复习了bit manipulation，two’s complement等二进制位运算方面的知识。编码尽量采用&lt;code class=&quot;highlighter-rouge&quot;&gt;c++, javascript, python&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;twos-complement&quot;&gt;two’s complement补码&lt;/h2&gt;
&lt;p&gt;About binary还有关于2进制，位运算什么的&lt;/p&gt;

&lt;p&gt;Two’s complement is the way every computer I know of chooses to represent integers. To get the two’s complement negative notation of an integer, you write out the number in binary. You then invert the digits, and add one to the result.
Suppose we’re working with 8 bit quantities (for simplicity’s sake) and suppose we want to find how -28 would be expressed in two’s complement notation. First we write out 28 in binary form.
00011100
Then we invert the digits. 0 becomes 1, 1 becomes 0.
11100011
Then we add 1.
11100100
That is how one would write -28 in 8 bit binary.&lt;/p&gt;

&lt;p&gt;Arithmetic with Two’s Complement&lt;/p&gt;

&lt;p&gt;One of the nice properties of two’s complement is that addition and subtraction is made very simple. With a system like two’s complement, the circuitry for addition and subtraction can be unified, whereas otherwise they would have to be treated as separate operations.
In the examples in this section, I do addition and subtraction in two’s complement, but you’ll notice that every time I do actual operations with binary numbers I am always adding.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;位运算实现加法&lt;/h2&gt;

&lt;p&gt;用位运算实现加法也就是计算机用二进制进行运算，32位的CPU只能表示32位内的数，这里先用1位数的加法来进行，在不考虑进位的基础上，如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 + 1 = 0
1 + 0 = 1
0 + 1 = 1
0 + 0 = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很明显这几个表达式可以用位运算的“^”来代替，如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0 这样我们就完成了简单的一位数加法，那么要进行二位的加法，这个方法可行不可行呢？肯定是不行的，矛盾就在于，如何去 获取进位？要获取进位我们可以如下思考：

0 &amp;amp; 0 = 0
1 &amp;amp; 0 = 0
0 &amp;amp; 1 = 0
1 &amp;amp; 1 = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//换个角度看就是这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 &amp;amp; 0 = 不进位
1 &amp;amp; 0 = 不进位
0 &amp;amp; 1 = 不进位
1 &amp;amp; 1 = 进位
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;正好，在位运算中，我们用“«”表示向左移动一位，也就是“进位”。那么我们就可以得到如下的表达式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//进位可以用如下表示：
(x&amp;amp;y)&amp;lt;&amp;lt;1 到这里，我们基本上拥有了这样两个表达式

x^y //执行加法
(x&amp;amp;y)&amp;lt;&amp;lt;1 //进位操作

a + b = a ^ b + ((a &amp;amp; b) &amp;lt;&amp;lt; 1) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;代码实现&lt;/h2&gt;

&lt;p&gt;下面的代码还支持 传 负数进去… 好神奇。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

#define __DEBUG__       1

int MyAdd(int a, int b)
{
    /* 定理1：
     * if (0 == (a &amp;amp; b)) {
     *     a + b == a ^ b;
     * }
     * 换句话说就是，如果两数相加时没有进位，则加法运算可由异或运算代替。
     * 两数相与生存下来的位就是相加会向左产生进位的位，所以
     * （a &amp;amp; b)就可以判断两数相加会不会产生进位，而且（a &amp;amp; b) &amp;lt;&amp;lt; 1
     * 就是所有--进位位--的进位值之和。
     * */
    /* 定理2：a + b = a ^ b + ((a &amp;amp; b) &amp;lt;&amp;lt; 1)
     * 就是把加法拆成--每位相加的和--与--进位值--两部分相加
     * 等式右边也是加法，又可以拆，这就形成了一个递归的过程
     * 要使递归终止，需使用定理1，也就是不再有进位，定理2等式右边
     * 的加号就可以换成异或符号。
     * */

    /* 这里的a, b可视为某两个数A和B的--每位相加的和--和--进位值 */
    int cf = a &amp;amp; b;
    int sum = a ^ b;

    while (cf) {
        a = sum;
        b = cf &amp;lt;&amp;lt; 1;
        cf = a &amp;amp; b;
        sum = a ^ b;
    }

    #if __DEBUG__
    assert(sum == a + b);
    #endif

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 03 Aug 2016 18:06:24 +0800</pubDate>
        <link>http://woodghost.github.io/myblog/2016/08/leetcode-01/</link>
        <guid isPermaLink="true">http://woodghost.github.io/myblog/2016/08/leetcode-01/</guid>
        
        <category>algorithm</category>
        
        
      </item>
    
  </channel>
</rss>
